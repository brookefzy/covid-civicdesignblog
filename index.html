<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>NYCzip

    </title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <!-- <script src="https://d3js.org/topojson.v2.js"></script> -->
    <script src="https://d3js.org/topojson.v2.min.js"></script>
<!--    <script src="boston_neighborhoods.json"></script> -->

   <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<!--    <script src="boston_311.csv"></script> -->

    <style>
 	
 	</style>
</head>

<body>
	<div id="main">

	</div>
<script type="text/javascript">

var bosNeighborhoods='https://raw.githubusercontent.com/brookefzy/covid-civicdesignblog/master/data/blogdata_nyc.geojson'

var bos311url = "https://raw.githubusercontent.com/brookefzy/covid-civicdesignblog/master/data/blogdata_nyc.csv"



var width = 2700
var height = 900

var svg = d3.select("body").append("svg")
                    .attr("width", width)
                    .attr("height", height);
	

var albersProjection = d3.geoAlbers()
  .scale(90000)
  .rotate([74.06, 0])
  .center([0,40.88])
  .translate([width/10, height/10])
	
var geoPath = d3.geoPath()
	.projection(albersProjection)

var color = d3.scaleQuantize()
    .domain([0, 200000]) 
    .range(d3.schemePurples[9]);


var bostwitter=d3.map();


var promises = [
                d3.json(bosNeighborhoods),
                d3.csv(bos311url, function(d) {bostwitter.set(d.zipcode, +d.test_pop);})
                    ]

Promise.all(promises).then(ready)

// Promise.all(promises).then(function(data){
//     var nyc=data[0]
//     var test=data[1]
//     nycshp={}

//     for (i=0; i<length(nyc.features);i++) {
//         var zipcode=nyc.features[i].properties.ZIPCODE
//         nycshp

//     }



//     console.log(nyc.features[0].properties.ZIPCODE)
//     svg.append("path")
//         .attr("d", geoPath(nyc))
//         .attr("fill",function(d) { 
//             console.log()
//             // console.log("d: ",bostwitter.get(d.features))
//             //console.log(bostwitter)
            
//             return color(d.twitter = bostwitter.get(d.features.properties.ZIPCODE)) })
//         .attr("stroke","white")
// })



function ready(bosNeighbor) {
    // console.log(bosNeighbor)
    var nyc=bosNeighbor[0]
    // var test=bosNeighbor[1]



    svg.append("path")

        .attr("d", geoPath(nyc))
        .data(nyc.features)
        .attr("stroke","white")
		// console.log(nyc.features)
		.attr("fill", function(d) { 
            console.log(nyc.features)
            console.log(d.properties.POPULATION)
            // console.log("d: ",bostwitter.get(d.POPULATION))
            //console.log(bostwitter)
            
            return color(d.properties.POPULATION)})
        .enter().append("path")


	}


// const tweetsbyneigh = {};

// var testmap = d3.map();

// var promises = [
// 	d3.json(bosNeighborhoods),
// 	d3.csv(bos311url, function(d) { testmap.set(
// 		tweetsbyneigh[d.Name] = +d.twitter);
// 	})
// 	]
// Promise.all(promises).then(ready)




// legend = g => {
//   const x = d3.scaleLinear()
//       .domain(d3.extent(color.domain()))
//       .rangeRound([0, 260]);
// // 
//   g.selectAll("rect")
//     .data(color.range().map(d => color.invertExtent(d)))
//     .join("rect")
//       .attr("height", 8)
//       .attr("x", d => x(d[0]))
//       .attr("width", d => x(d[1]) - x(d[0]))
//       .attr("fill", d => color(d[0]));
// // 
//   g.append("text")
//       .attr("x", x.range()[0])
//       .attr("y", -6)
//       .attr("fill", "currentColor")
//       .attr("text-anchor", "start")
//       .attr("font-weight", "bold")
//       .text("Tweets per neighborhood (Log Scale)");
// 
//   g.call(d3.axisBottom(x)
//       .tickSize(13)
//       .tickFormat(d => Math.exp
//                   (d).toFixed(1))
//       .tickValues(color.range().slice(1).map(d => color.invertExtent(d)[0])))
//     .select(".domain")
//       .remove();
// } 
// 
// 
// 
// // append new group for legend
//   svg.append("g")
//       .attr("transform", "translate(400,30)")
//       .call(legend);
// 
// 
// tooltip = d3.select("body")
//       .append("div")
//       .style("position", "absolute")
//       .style("z-index", "1")
//       .style("visibility", "hidden")
//       .style("background","white")
//       .style("opacity","0.6")
//       .style("padding","5px")
//       .style("font-family", "'Open Sans', sans-serif")
//       .style("font-size", "12px"); 
//       
// 
// // Call tooltip 
// tooltip
// 
// // Classic D3... Select non-existent elements, bind the data, append the elements, and apply attributes
// svg.selectAll( "path" )
//     .data(topojson.feature(bosNeighborhoods, bosNeighborhoods.objects.boston_neigh).features )
//     .enter()
//     .append( "path" )
//     .attr( "fill", d => color(Math.log(tweetsbyneigh[d.properties.Name])) )
//     .attr( "stroke", "#333")
//     .attr( "d", bos_geoPath )
//     // Code added after tooltip is called
//     .on("mouseover", d => tooltip.style("visibility", "visible").text(d.properties.Name + ": " + tweetsbyneigh[d.properties.Name]))
//     .on("mousemove", d => tooltip.style("top", (d3.event.pageY-10)+"px").style("left",(d3.event.pageX+10)+"px").text(d.properties.Name + ": " + tweetsbyneigh[d.properties.Name]))
//     .on("mouseout", d => tooltip.style("visibility", "hidden"))
//   
//  
//     
    
    

</script>
</body>
</html>
